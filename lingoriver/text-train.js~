// ui and translate kickoff, started by main.js 

function TextTrain(sentences) {

    this.pushSentence = pushSentence

    var trainSentenceIndex = 0
    var wordIndex = 0

    var clearInputOnInput = false

    var suggestionsE
    var langASentenceE
    var langBSentenceE
    var inputDoneE
    var inputE
    var placeholderE

    //    startButton.style.display = "none"
    //var doorUI = document.getElementById("ht-door")
    //doorUI.style.display = "none"

    // ui
//    var html = ''

//    var displayMode = 1 // 0: whole sentence printed, type in middle, 1: whole sentence as placeholder

    var container = document.getElementById("container")
    container.style = "font-size:14pt; position:relative;"
//    container.innerHTML = html
    //    document.querySelectorAll(".WFnNle")[0].appendChild(container)
//    document.body.appendChild(container)

    inputE = document.getElementById("tt-input2")
    placeholderE = document.getElementById("persistent-placeholder")
    inputDoneE = document.getElementById("tt-input-done")
    langBSentenceE = document.getElementById("tt-lang-b")
    langASentenceE = document.getElementById("tt-lang-a")
    suggestionsE = document.getElementById("tt-suggestions")
    helpE = document.getElementById("tt-help")
    var closeButton = document.getElementById("tt-close")

    // ui final touches
    inputE.focus()
    startTranslateWait()

    // TODO clearer error handling?
    kickOff()
/*    if(!kickOff()) {
//      alert("Paste text to the translate field, and click 'Start Text Train' again")
        return
    }  */



    inputE.addEventListener("input", function() {
        var s = inputE.value
        // different from placeholder? hide placeholder
        if (s != placeholderE.value.substring(0, s.length)) {
            // remove the last character
//          inputE.value = s.substring(0, s.length-1)
            placeholderE.style.visibility = "hidden"
        } else {
            placeholderE.style.visibility = "visible"
        }

        // word break
        if (s.charAt(s.length-1) == " ") { 
            handleWordBreak()
        }
    })

    inputE.addEventListener("keydown", function(event) {
        if (event.code == "Tab") {     // skip sentence
            if(hasNextSentence()) {
                nextSentence()
                inputE.focus()
            } else {
                close()
            }
        } else if (event.code == "Escape") { // exit
            close()
        } else if (event.code == "Enter") { // word break
            handleWordBreak()
        }
    })

    helpE.addEventListener("click", function() {
        alert("Retype the second sentence. \n Keyboard shortcuts: \n tab - skip sentence \n escape - quit")
    })

    // pushSentence lets the caller add new sentences
    function pushSentence(s) {
	sentences.push(s)
    }

    // kickOff starts the data retrieving
    // returns false if no start, else true
    function kickOff() {
//      swd = new SentenceWordData()
//      swd.FillWithChapterString()

        // hacky, maybe on file loaded etc
        nextSentenceTranslated()

/*      if (swd.SentenceN > 0) {
            //            swd.onSentenceTranslated = nextSentenceTranslated
            return true
        }
        return false */
    }

    // handleWordBreak takes care of words the user enters
    function handleWordBreak() {
        if(!sentences[trainSentenceIndex]) {
            console.log("no sentence")
            return
        }
        var wps = sentences[trainSentenceIndex].wordPairs
        // input does not match source
        var userIn = inputE.value.trim()
        //        var check = wordTranslitForUser(wps[wordIndex].Hebrew)
        var check = wps[wordIndex].langA
        if (userIn !== check && clearNonLetters(userIn) != clearNonLetters(check)) {
//            console.log("input '"+userIn+"' does not match source '"+check+"'")
            return
        }

        // input matches, continue with...
        if (wordIndex < wps.length - 1) {     // ...next word
            inputDoneE.innerHTML +=  check + " "
            wordIndex++
            inputE.value = ""
            updateSuggestions()
/*            if (displayMode == 1) {
                placeholderE.value = placeholderE.value.replace(/[^ ]+ /, "")
            } */
        }  else if (hasNextSentence()) {     // ...next sentence
            nextSentence()
            updateSuggestions()
        }
        else {      // ...done
            close()
        }
    }

    // hasNextSentence: is there a next sentence?
    function hasNextSentence() {
        return trainSentenceIndex < sentences.length - 1
    }

    // close closes the ui
    function close() {
        // remove container
        container.parentNode.removeChild(container)
        // show start ui with start button
//        doorUI.style.display = "inline"

        trainSentenceIndex = 0
        wordIndex = 0

/*      if(swd) {
            swd.CloseMethod()
            swd = null
        }*/

    }

    // display the next sentence
    function nextSentence() {

        inputE.value = ""
        wordIndex = 0
        trainSentenceIndex ++

        updateTrainSentence()
        // translation not yet available
/*      if (trainSentenceIndex > sentences.length - 1) {
//            console.log("translation not yet there")
            swd.onSentenceTranslated = nextSentenceTranslated()
            startTranslateWait()
        } else {
            updateTrainSentence()
        } */
    }

    // update the query sentence
    function updateTrainSentence() {
        var sentence = sentences[trainSentenceIndex]

//      stopTranslateWait()
        inputDoneE.innerText = ""
        // remember to hide langA and keep langB
        clearInputOnInput = true

        if (!sentence) {
            console.log("error no sentence")
            return
        }

        // get word boundaries for chinese.
        // todo maybe: for chinese, thai, etc stick words together, else translit sentence to keep punctuation?
/*        var langA = ""
        for (var w of sentence.wordPairs) {
            //            langA += wordTranslitForUser(w.Hebrew) + " "
            langA += w.Hebrew + " "
            } */
	var langA = sentence.langA

        var langB = sentence.langB
        // translit? or ist this too much?
//      langB += "<br/>hineh yhvh boqeq ha’arets ubolqah ve‘ivah faneha veheifits yoshebeha."
//      langB = translit(sentence.english) // maybe todo: same for langB as for langA?

        //      langBSentenceE.innerText = langB
        langBSentenceE.innerHTML = langB
/*        switch (displayMode) {
          case 0: */
	langBSentenceE.innerText = langB
        langASentenceE.innerText = langA

/*        case 1:
            placeholderE.value = langA
        } */
    }

    // use the whole word pool
    function generateSuggestions() {
        if (!sentences[trainSentenceIndex]) { // not so cool, but at least avoid crash when current sentence is undefined?
            return ""
        }

        var string = ""
        // three next
        var wp = sentences[trainSentenceIndex].wordPairs
        for(var n = 0; n < 3 && wordIndex + n < wp.length; n++) { // three suggestions
        // for(var n = 0; n < 1 && wordIndex + n < words.length; n++) { // one suggestion
//            if (swd.wordDict[words[wordIndex+n]]) {
                // add langB
	    //              var langB = swd.wordDict[words[wordIndex+n]]
	    var langB = wp[wordIndex+n].langB
	    string += translit(langB) + " "
	    // string += translit(langB) + " "

            // add langA
            var langA = wp[wordIndex+n].langA
	    //            string += wordTranslitForUser(langA) + "<br/>"
	    string += translit(langA) + "<br/>"
        }
        return string

        // simple
        //    return target[1] + " " + target[0] + "<br/>"
    } 

    // for single word s, remove blanks between syllables, e.g. chinese
/*    function wordTranslitForUser(s) {
        return translit(s).replace(/\s/g, "")
    } */

    // remove trailing
    function clearNonLetters(s) {
        return s.replace(/\P{Letter}/ug, "")
    }

    function startTranslateWait() {
//      console.log("start translate wait")
        // show wait message
        //      inputE.placeholder = "translating words..."
//        placeholderE.value = "translating words..."
    }
    function stopTranslateWait() {
        // hide wait message
        //      inputE.placeholder = ""
        placeholderE.value = ""
    }

    // if translation
    function nextSentenceTranslated() {
//      stopTranslateWait()

        updateTrainSentence()
        updateSuggestions()

        // remove listener
//      swd.onSentenceTranslated = null
    } 

    // in-place shuffle
    function shuffle(array) {
        array.sort((a, b) => Math.random() - 0.5)
    }



    // update the three suggestions
    // and maybe input placeholder
    function updateSuggestions() {
        //    suggestionsE.innerHTML = generateSuggestions(train[trainSentenceIndex].wordPairs, wordIndex)
        // inputE.placeholder = train[trainSentenceIndex].wordPairs[wordIndex][1]

        // below
      suggestionsE.innerHTML = generateSuggestions()

        // try out: placeholder

/*        if (!sentences[trainSentenceIndex]) { // not so cool, but at least avoid crash when current sentence is undefined?
            return 
        }
        var wordPairs = sentences[trainSentenceIndex].wordPairs

        // langB
        var langB = wordPairs[wordIndex].langB
	//      langB = translit(langB)
        // langA
        var langA = wordPairs[wordIndex].langA
//      langA = wordTranslitForUser(langA) 

        //      inputE.placeholder = langA + " " + langB */
/*        switch (displayMode) {
        case 0:
            placeholderE.value = langA + " " + langB
            suggestionsE.style.display = "none"
            break
        case 1:
            suggestionsE.textContent = langB
        }*/
    }

    // remove diacritics in string s
    function clearDiacritics(s) {
        s = s.normalize("NFD")
        return s.replace(/\p{Diacritic}/ug, "")
    }

    function ttInput(text) {
        console.log("input " + text)
    }
}
